// Système de carte interactive et calendrier synchronisés
// Variables globales
let map;
let markers = [];
let allEvents = [];
let calendar;

// Cache de géocodage pour éviter les requêtes répétées
let geocodeCache = {};

// Couleurs
const COLOR_FURRY = '#43BCCD';
const COLOR_OTHER = '#DDA600';
const COLOR_PAST = '#999';

// Mots-clés pour détecter les événements furry
const FURRY_KEYWORDS = ['furry', 'furries', 'fursona', 'fursuit', 'anthro', 'canthro', 'faun'];

/**
 * Détecte si un événement est furry
 */
function isFurryEvent(title) {
  const titleLower = title.toLowerCase();
  return FURRY_KEYWORDS.some(keyword => titleLower.includes(keyword));
}

/**
 * Vérifie si un événement est passé
 */
function isPastEvent(endDate) {
  return new Date(endDate) < new Date();
}

/**
 * Initialise la carte Leaflet
 */
function initMap() {
  // Créer la carte centrée sur la France
  map = L.map('interactive-map').setView([47.0, 2.0], 6);
  
  // Ajouter la couche OpenStreetMap
  L.tileLayer('https://{s}.tile.openstreetmap.org/{z}/{x}/{y}.png', {
    attribution: '&copy; <a href="https://www.openstreetmap.org/copyright">OpenStreetMap</a> contributors',
    maxZoom: 19
  }).addTo(map);
  
  console.log('✅ Carte Leaflet initialisée');
  
  // Charger le cache depuis localStorage
  loadGeocodeCache();
}

/**
 * Charge le cache de géocodage depuis localStorage
 */
function loadGeocodeCache() {
  try {
    const cached = localStorage.getItem('geocodeCache');
    if (cached) {
      geocodeCache = JSON.parse(cached);
      console.log(`📦 Cache géocodage chargé: ${Object.keys(geocodeCache).length} entrées`);
    }
  } catch (e) {
    console.warn('⚠️ Erreur chargement cache:', e);
  }
}

/**
 * Sauvegarde le cache de géocodage dans localStorage
 */
function saveGeocodeCache() {
  try {
    localStorage.setItem('geocodeCache', JSON.stringify(geocodeCache));
  } catch (e) {
    console.warn('⚠️ Erreur sauvegarde cache:', e);
  }
}

/**
 * Extrait les coordonnées GPS depuis la location ICAL
 */
function extractCoordinates(event) {
  // Si l'événement a une propriété geo dans iCal
  if (event.geo && event.geo.lat && event.geo.lon) {
    return { lat: event.geo.lat, lon: event.geo.lon };
  }
  
  // Sinon, essayer de parser depuis la location
  const location = event.extendedProps.location;
  if (!location) return null;
  
  // Rechercher un pattern geo: dans la location
  const geoMatch = location.match(/geo:([-\d.]+),([-\d.]+)/);
  if (geoMatch) {
    return { lat: parseFloat(geoMatch[1]), lon: parseFloat(geoMatch[2]) };
  }
  
  return null;
}

/**
 * Ajoute un marqueur sur la carte
 */
async function addMarker(event) {
  if (!event.extendedProps.location) {
    console.warn('⚠️ Pas de localisation pour:', event.title);
    return;
  }
  
  // Essayer d'extraire les coordonnées
  let coords = extractCoordinates(event);
  
  // Vérifier le cache
  const location = event.extendedProps.location;
  if (!coords && geocodeCache[location]) {
    coords = geocodeCache[location];
    console.log('📦 Cache hit:', location);
  }
  
  // Si pas de coordonnées, utiliser le géocodage Nominatim
  if (!coords) {
    coords = await geocodeLocation(location);
    if (coords) {
      geocodeCache[location] = coords;
      saveGeocodeCache();
    }
  }
  
  if (coords) {
    createMarker(coords.lat, coords.lon, event);
  } else {
    console.warn('❌ Impossible de géolocaliser:', event.title);
  }
}

/**
 * Géocodage avec Nominatim (OpenStreetMap) - rate limited
 */
const geocodeQueue = [];
let geocoding = false;

async function geocodeLocation(address) {
  return new Promise((resolve) => {
    geocodeQueue.push({ address, resolve });
    processGeocodeQueue();
  });
}

async function processGeocodeQueue() {
  if (geocoding || geocodeQueue.length === 0) return;
  
  geocoding = true;
  const { address, resolve } = geocodeQueue.shift();
  
  try {
    const response = await fetch(
      `https://nominatim.openstreetmap.org/search?format=json&q=${encodeURIComponent(address)}&limit=1`,
      {
        headers: {
          'User-Agent': 'LaMeuteNormande/1.0'
        }
      }
    );
    
    const data = await response.json();
    
    if (data && data.length > 0) {
      console.log('✅ Géocodage réussi:', address);
      resolve({
        lat: parseFloat(data[0].lat),
        lon: parseFloat(data[0].lon)
      });
    } else {
      console.warn('⚠️ Aucun résultat géocodage pour:', address);
      resolve(null);
    }
  } catch (error) {
    console.error('❌ Erreur géocodage:', address, error);
    resolve(null);
  }
  
  // Attendre 1 seconde avant la prochaine requête (rate limit Nominatim)
  setTimeout(() => {
    geocoding = false;
    processGeocodeQueue();
  }, 1000);
}

/**
 * Crée un marqueur sur la carte
 */
function createMarker(lat, lon, event) {
  if (!lat || !lon || isNaN(lat) || isNaN(lon)) {
    console.error('❌ Coordonnées invalides pour:', event.title, lat, lon);
    return;
  }
  
  const isFurry = event.extendedProps.isFurry;
  const isPast = isPastEvent(event.end || event.start);
  
  // Choisir la couleur du marqueur
  let markerColor = isFurry ? COLOR_FURRY : COLOR_OTHER;
  if (isPast) markerColor = COLOR_PAST;
  
  // Créer une icône personnalisée
  const icon = L.divIcon({
    className: 'custom-marker',
    html: `<div style="background-color: ${markerColor}; width: 30px; height: 30px; border-radius: 50%; border: 3px solid white; box-shadow: 0 2px 8px rgba(0,0,0,0.4); cursor: pointer;"></div>`,
    iconSize: [30, 30],
    iconAnchor: [15, 15]
  });
  
  // Créer le marqueur
  const marker = L.marker([lat, lon], { icon: icon });
  
  // Créer le popup
  const startDate = new Date(event.start);
  const endDate = event.end ? new Date(event.end) : null;
  
  let dateStr = startDate.toLocaleDateString('fr-FR', { day: 'numeric', month: 'short', year: 'numeric' });
  if (endDate && endDate.getTime() !== startDate.getTime()) {
    dateStr += ' - ' + endDate.toLocaleDateString('fr-FR', { day: 'numeric', month: 'short', year: 'numeric' });
  }
  
  const popupContent = `
    <div class="map-popup">
      <div class="map-popup-title">${isFurry ? '🐾' : '🎮'} ${event.title}</div>
      <div class="map-popup-date">📅 ${dateStr}</div>
      <div class="map-popup-location">📍 ${event.extendedProps.location}</div>
      <button class="map-popup-btn ${isFurry ? 'furry' : 'other'}" onclick="openEventModalFromMap('${event.id}')">
        Voir les détails
      </button>
    </div>
  `;
  
  marker.bindPopup(popupContent, {
    maxWidth: 300,
    closeButton: true
  });
  
  marker.addTo(map);
  markers.push({ marker, event });
  
  console.log('✅ Marqueur ajouté:', event.title);
}

/**
 * Ouvre la modal depuis la carte
 */
window.openEventModalFromMap = function(eventId) {
  const event = allEvents.find(e => e.id === eventId);
  if (event) {
    map.closePopup();
    openEventModal(event);
  }
};

/**
 * Ouvre la popup d'événement
 */
function openEventModal(event) {
  const modal = document.getElementById('eventModal');
  const modalTitle = document.getElementById('modalTitle');
  const modalBody = document.getElementById('modalBody');
  
  const isFurry = event.extendedProps.isFurry;
  const emoji = isFurry ? '🐾' : '🎮';
  
  // Titre
  modalTitle.innerHTML = `<span class="event-modal-emoji">${emoji}</span> ${event.title}`;
  
  // Contenu
  let bodyHTML = '';
  
  // Dates
  if (event.start) {
    const startDate = new Date(event.start);
    const endDate = event.end ? new Date(event.end) : null;
    
    const dateOptions = { weekday: 'long', year: 'numeric', month: 'long', day: 'numeric' };
    const timeOptions = { hour: '2-digit', minute: '2-digit' };
    
    bodyHTML += `
      <div class="event-info-row">
        <div class="event-info-icon">📅</div>
        <div class="event-info-content">
          <div class="event-info-label">Date & Heure</div>
          <div class="event-info-text">
            ${startDate.toLocaleDateString('fr-FR', dateOptions)}
            ${startDate.getHours() !== 0 ? ' à ' + startDate.toLocaleTimeString('fr-FR', timeOptions) : ''}
    `;
    
    if (endDate && endDate.getTime() !== startDate.getTime()) {
      bodyHTML += `
            <br>→ ${endDate.toLocaleDateString('fr-FR', dateOptions)}
            ${endDate.getHours() !== 0 ? ' à ' + endDate.toLocaleTimeString('fr-FR', timeOptions) : ''}
      `;
    }
    
    bodyHTML += `
          </div>
        </div>
      </div>
    `;
  }
  
  // Lieu
  if (event.extendedProps.location) {
    const locationText = event.extendedProps.location;
    const mapsUrl = `https://www.google.com/maps/search/?api=1&query=${encodeURIComponent(locationText)}`;
    
    bodyHTML += `
      <div class="event-info-row">
        <div class="event-info-icon">📍</div>
        <div class="event-info-content">
          <div class="event-info-label">Lieu</div>
          <div class="event-info-text">
            <a href="${mapsUrl}" target="_blank" rel="noopener">${locationText}</a>
          </div>
        </div>
      </div>
    `;
  }
  
  // Description
  if (event.extendedProps.description) {
    let description = event.extendedProps.description;
    const urlRegex = /(https?:\/\/[^\s]+)/g;
    description = description.replace(urlRegex, '<a href="$1" target="_blank" rel="noopener">$1</a>');
    
    bodyHTML += `
      <div class="event-info-row">
        <div class="event-info-icon">📝</div>
        <div class="event-info-content">
          <div class="event-info-label">Description</div>
          <div class="event-info-text event-description">${description}</div>
        </div>
      </div>
    `;
  }
  
  // Badge type
  bodyHTML += `
    <div style="text-align: center;">
      <span class="event-badge">${isFurry ? '🔵 Événement Furry' : '🟠 Autre Événement'}</span>
    </div>
  `;
  
  // Boutons d'itinéraire
  if (event.extendedProps.location) {
    const locationText = event.extendedProps.location;
    
    const wazeUrl = `https://waze.com/ul?q=${encodeURIComponent(locationText)}&navigate=yes`;
    const googleMapsUrl = `https://www.google.com/maps/dir/?api=1&destination=${encodeURIComponent(locationText)}`;
    const appleMapsUrl = `https://maps.apple.com/?daddr=${encodeURIComponent(locationText)}`;
    
    bodyHTML += `
      <div class="event-navigation-buttons">
        <a href="${wazeUrl}" target="_blank" rel="noopener" class="event-nav-btn waze" title="Ouvrir dans Waze">
          <span>Waze</span>
        </a>
        <a href="${googleMapsUrl}" target="_blank" rel="noopener" class="event-nav-btn google-maps" title="Ouvrir dans Google Maps">
          <span>Google Maps</span>
        </a>
        <a href="${appleMapsUrl}" target="_blank" rel="noopener" class="event-nav-btn apple-plans" title="Ouvrir dans Plans">
          <span>Apple Plans</span>
        </a>
      </div>
    `;
  }
  
  modalBody.innerHTML = bodyHTML;
  modal.style.display = 'block';
  
  // Fermeture au clic en dehors
  modal.onclick = function(e) {
    if (e.target === modal) {
      closeEventModal();
    }
  };
  
  // Fermeture avec Escape
  document.addEventListener('keydown', handleEscapeKey);
}

function closeEventModal() {
  const modal = document.getElementById('eventModal');
  modal.style.display = 'none';
  document.removeEventListener('keydown', handleEscapeKey);
}

function handleEscapeKey(e) {
  if (e.key === 'Escape') {
    closeEventModal();
  }
}

/**
 * Charge les événements depuis Zoho Calendar
 */
async function loadEvents() {
  const icalUrl = 'https://calendar.zoho.eu/ical/zz080112301ab3047e81313179c3ee5fd4b00c2a7157b801985735a7b689432472bf947fc87d113e58fdc5e83eea16ec9dc7bc3e4c';
  const corsProxy = 'https://corsproxy.io/?';
  
  try {
    console.log('🔄 Chargement des événements depuis Zoho...');
    
    const response = await fetch(corsProxy + encodeURIComponent(icalUrl));
    if (!response.ok) throw new Error('Erreur chargement iCal');
    
    const icalData = await response.text();
    console.log('✅ iCal Zoho chargé, parsing...');
    
    // Parser le fichier iCal
    const jcalData = ICAL.parse(icalData);
    const comp = new ICAL.Component(jcalData);
    const vevents = comp.getAllSubcomponents('vevent');
    
    console.log('📅 Événements trouvés:', vevents.length);
    
    // Convertir en format utilisable
    const events = vevents.map(vevent => {
      const event = new ICAL.Event(vevent);
      const color = isFurryEvent(event.summary) ? COLOR_FURRY : COLOR_OTHER;
      
      // Extraire les coordonnées geo si disponibles
      let geo = null;
      try {
        const geoProperty = vevent.getFirstProperty('geo');
        if (geoProperty) {
          const geoValue = geoProperty.getFirstValue();
          if (geoValue && geoValue.latitude && geoValue.longitude) {
            geo = {
              lat: geoValue.latitude,
              lon: geoValue.longitude
            };
          }
        }
      } catch (e) {
        // Pas de propriété geo
      }
      
      return {
        id: event.uid,
        title: event.summary,
        start: event.startDate.toJSDate(),
        end: event.endDate.toJSDate(),
        description: event.description || '',
        location: event.location || '',
        backgroundColor: color,
        borderColor: color,
        geo: geo,
        extendedProps: {
          location: event.location,
          description: event.description,
          isFurry: isFurryEvent(event.summary)
        }
      };
    });
    
    allEvents = events;
    
    console.log('✅ Événements parsés:', events.length);
    
    // Mettre à jour la carte ET le calendrier en parallèle
    await Promise.all([
      updateMap(events),
      updateCalendar(events)
    ]);
    
    const furryCount = events.filter(e => e.extendedProps.isFurry).length;
    const otherCount = events.filter(e => !e.extendedProps.isFurry).length;
    
    console.log(`✅ ${events.length} événements chargés (${furryCount} furry, ${otherCount} autres)`);
    
    // Message de succès
    showSuccessMessage(events.length, furryCount, otherCount);
    
  } catch (error) {
    console.error('❌ Erreur chargement iCal:', error);
    showErrorMessage();
  }
}

/**
 * Met à jour la carte avec les événements - EN PARALLÈLE
 */
async function updateMap(events) {
  console.log('🗺️ Mise à jour de la carte...');
  
  // Effacer les anciens marqueurs
  markers.forEach(m => m.marker.remove());
  markers = [];
  
  // Ajouter les nouveaux marqueurs EN PARALLÈLE
  await Promise.all(events.map(event => addMarker(event)));
  
  console.log(`✅ ${markers.length}/${events.length} marqueurs ajoutés sur la carte`);
  
  // Ajuster la vue pour englober tous les marqueurs
  if (markers.length > 0) {
    const group = L.featureGroup(markers.map(m => m.marker));
    map.fitBounds(group.getBounds().pad(0.1));
  }
}

/**
 * Met à jour le calendrier
 */
function updateCalendar(events) {
  const calendarEl = document.getElementById('fullcalendar');
  
  if (calendar) {
    calendar.destroy();
  }
  
  calendar = new FullCalendar.Calendar(calendarEl, {
    initialView: 'dayGridMonth',
    locale: 'fr',
    firstDay: 1,
    headerToolbar: {
      left: 'prev,next today',
      center: 'title',
      right: 'dayGridMonth,dayGridWeek,listMonth'
    },
    buttonText: {
      today: "Aujourd'hui",
      month: 'Mois',
      week: 'Semaine',
      list: 'Liste'
    },
    events: events,
    eventClick: function(info) {
      info.jsEvent.preventDefault();
      openEventModal(info.event);
    },
    eventDidMount: function(info) {
      const isFurry = info.event.extendedProps.isFurry;
      info.el.title = (isFurry ? '🐾 ' : '🎮 ') + info.event.title + 
        (info.event.extendedProps.location ? '\n📍 ' + info.event.extendedProps.location : '') +
        '\n' + (isFurry ? '🔵 Événement furry' : '🟠 Autre événement');
    },
    height: '100%',
    aspectRatio: 1.5,
    eventDisplay: 'block',
    displayEventTime: false,
    weekNumbers: false,
    navLinks: true,
    editable: false,
    dayMaxEvents: 3,
    moreLinkText: 'plus'
  });

  calendar.render();
  console.log('✅ Calendrier mis à jour');
  
  return Promise.resolve();
}

/**
 * Affiche un message de succès
 */
function showSuccessMessage(total, furry, other) {
  const successMsg = document.createElement('div');
  successMsg.style.cssText = 'position: fixed; top: 100px; right: 20px; background: rgba(67, 188, 205, 0.95); color: white; padding: 1rem 1.5rem; border-radius: 0.5rem; z-index: 9999; font-weight: 600; box-shadow: 0 4px 12px rgba(0,0,0,0.3);';
  successMsg.innerHTML = `✅ ${total} événements chargés<br><small>🔵 ${furry} furry · 🟠 ${other} autres</small>`;
  document.body.appendChild(successMsg);
  
  setTimeout(() => {
    successMsg.style.transition = 'opacity 0.5s';
    successMsg.style.opacity = '0';
    setTimeout(() => successMsg.remove(), 500);
  }, 4000);
}

/**
 * Affiche un message d'erreur
 */
function showErrorMessage() {
  const calendarEl = document.getElementById('fullcalendar');
  calendarEl.innerHTML = `
    <div style="padding: 2rem; color: #fff; text-align: center;">
      <h3>❌ Erreur de chargement</h3>
      <p>Impossible de charger les événements depuis Zoho Calendar.</p>
      <p><small>Vérifiez votre connexion Internet ou contactez l'administrateur.</small></p>
    </div>
  `;
}

// Initialisation au chargement de la page
document.addEventListener('DOMContentLoaded', function() {
  console.log('🚀 Initialisation carte et calendrier...');
  
  // Initialiser la carte
  initMap();
  
  // Charger les événements
  loadEvents();
  
  // Recharger toutes les 5 minutes pour actualisation auto
  setInterval(() => {
    console.log('🔄 Actualisation automatique...');
    loadEvents();
  }, 5 * 60 * 1000);
});
