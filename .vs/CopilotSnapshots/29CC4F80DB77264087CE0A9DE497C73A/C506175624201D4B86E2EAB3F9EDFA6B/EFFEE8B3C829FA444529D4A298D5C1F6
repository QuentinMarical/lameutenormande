/**
 * Système de Navigation par Onglets pour la Page Événements
 * Gestion des tabs avec effet fade + support tactile
 */

(function() {
  'use strict';

  // Configuration
  const CONFIG = {
    fadeDuration: 500,
    swipeThreshold: 50,
    swipeVelocityThreshold: 0.3,
    showSwipeHint: true,
    swipeHintDuration: 3000,
  };

  // Variables d'état
  let currentCard = 0;
  let totalCards = 0;
  let cards = null;
  let tabButtons = null;
  let isDesktop = false;
  let touchStartX = 0;
  let touchStartY = 0;
  let touchStartTime = 0;
  let isSwiping = false;

  /**
   * Initialisation
   */
  function init() {
    // Vérifier si on est sur la page événements
    if (!document.getElementById('eventsCardsContainer')) {
      return;
    }

    // Récupérer les éléments
    cards = document.querySelectorAll('.events-card');
    tabButtons = document.querySelectorAll('.events-tab-btn');

    if (!cards.length || !tabButtons.length) {
      console.error('Events Tabs: Éléments requis non trouvés');
      return;
    }

    // Compter les cartes
    totalCards = cards.length;

    // Vérifier le mode (desktop vs mobile)
    checkDesktopMode();

    // Initialiser les événements
    initEvents();

    // Afficher la première carte
    showCard(0, false);

    // Afficher l'indice de swipe si mobile
    if (!isDesktop && CONFIG.showSwipeHint) {
      showSwipeHint();
    }

    console.log('Events Tabs: Initialisé avec succès', {
      totalCards,
      isDesktop,
      swipeEnabled: !isDesktop
    });
  }

  /**
   * Vérifier si on est en mode desktop
   */
  function checkDesktopMode() {
    isDesktop = window.innerWidth >= 992;
  }

  /**
   * Initialiser les événements
   */
  function initEvents() {
    // Clics sur les boutons d'onglets
    tabButtons.forEach((btn, index) => {
      btn.addEventListener('click', () => {
        if (!isDesktop) {
          showCard(index, true);
          
          // Feedback haptique si disponible
          if (navigator.vibrate) {
            navigator.vibrate(10);
          }
        }
      });
    });

    // Touch events pour swipe sur mobile
    if (!isDesktop) {
      const container = document.getElementById('eventsCardsContainer');
      if (container) {
        container.addEventListener('touchstart', handleTouchStart, { passive: true });
        container.addEventListener('touchmove', handleTouchMove, { passive: false });
        container.addEventListener('touchend', handleTouchEnd, { passive: true });
      }
    }

    // Clavier
    document.addEventListener('keydown', handleKeyboard);

    // Resize avec debounce
    let resizeTimeout;
    window.addEventListener('resize', () => {
      clearTimeout(resizeTimeout);
      resizeTimeout = setTimeout(() => {
        const wasDesktop = isDesktop;
        checkDesktopMode();
        
        if (wasDesktop !== isDesktop) {
          updateDisplay();
        }
      }, 150);
    });

    // Gérer le chargement des iframes
    cards.forEach(card => {
      const iframe = card.querySelector('iframe');
      if (iframe) {
        iframe.addEventListener('load', () => {
          iframe.classList.add('loaded');
          card.classList.remove('loading');
        });
        
        // Timeout de sécurité
        setTimeout(() => {
          iframe.classList.add('loaded');
          card.classList.remove('loading');
        }, 3000);
      }
    });
  }

  /**
   * Gestion du début du touch
   */
  function handleTouchStart(e) {
    if (isDesktop) return;
    
    touchStartX = e.touches[0].clientX;
    touchStartY = e.touches[0].clientY;
    touchStartTime = Date.now();
    isSwiping = false;
  }

  /**
   * Gestion du mouvement touch
   */
  function handleTouchMove(e) {
    if (isDesktop || !touchStartX) return;

    const touchX = e.touches[0].clientX;
    const touchY = e.touches[0].clientY;
    const deltaX = touchX - touchStartX;
    const deltaY = touchY - touchStartY;

    // Détecter si c'est un swipe horizontal
    if (Math.abs(deltaX) > Math.abs(deltaY) && Math.abs(deltaX) > 10) {
      isSwiping = true;
      e.preventDefault(); // Empêcher le scroll pendant le swipe
    }
  }

  /**
   * Gestion de la fin du touch
   */
  function handleTouchEnd(e) {
    if (isDesktop || !touchStartX || !isSwiping) {
      touchStartX = 0;
      touchStartY = 0;
      isSwiping = false;
      return;
    }

    const touchEndX = e.changedTouches[0].clientX;
    const deltaX = touchEndX - touchStartX;
    const deltaTime = Date.now() - touchStartTime;
    const velocity = Math.abs(deltaX) / deltaTime;

    // Vérifier si le swipe est valide
    if (Math.abs(deltaX) > CONFIG.swipeThreshold || velocity > CONFIG.swipeVelocityThreshold) {
      if (deltaX > 0) {
        // Swipe vers la droite
        showCard(currentCard - 1, true);
      } else {
        // Swipe vers la gauche
        showCard(currentCard + 1, true);
      }

      // Feedback haptique
      if (navigator.vibrate) {
        navigator.vibrate(15);
      }
    }

    touchStartX = 0;
    touchStartY = 0;
    isSwiping = false;
  }

  /**
   * Gestion du clavier
   */
  function handleKeyboard(e) {
    if (isDesktop) return;

    switch(e.key) {
      case 'ArrowLeft':
      case '1':
        e.preventDefault();
        showCard(0, true);
        break;
      case 'ArrowRight':
      case '2':
        e.preventDefault();
        showCard(1, true);
        break;
      case 'Tab':
        // Laisser Tab fonctionner normalement
        break;
    }
  }

  /**
   * Afficher une carte spécifique
   */
  function showCard(index, animate = true) {
    // Vérifier l'index (avec wrap-around)
    if (index < 0) index = 0;
    if (index >= totalCards) index = totalCards - 1;
    
    // Si on est sur desktop, ne rien faire
    if (isDesktop) return;

    // Si c'est déjà la carte active, ne rien faire
    if (index === currentCard) return;

    // Mettre à jour l'index actuel
    const oldCard = currentCard;
    currentCard = index;

    // Mettre à jour les cartes avec animation
    updateCards(animate, oldCard);

    // Mettre à jour les boutons d'onglets
    updateTabButtons();

    // Annoncer le changement pour les lecteurs d'écran
    announceCardChange();
  }

  /**
   * Mettre à jour les cartes
   */
  function updateCards(animate, oldCardIndex) {
    cards.forEach((card, index) => {
      if (index === currentCard) {
        // Nouvelle carte active
        if (animate) {
          card.classList.add('entering');
          setTimeout(() => {
            card.classList.remove('entering');
          }, 500);
        }
        card.classList.add('active');
        
        // Marquer comme loading si iframe
        const iframe = card.querySelector('iframe');
        if (iframe && !iframe.classList.contains('loaded')) {
          card.classList.add('loading');
        }
      } else {
        // Cartes inactives
        card.classList.remove('active', 'entering', 'loading');
      }
    });
  }

  /**
   * Mettre à jour les boutons d'onglets
   */
  function updateTabButtons() {
    tabButtons.forEach((btn, index) => {
      if (index === currentCard) {
        btn.classList.add('active');
        btn.setAttribute('aria-current', 'true');
        btn.setAttribute('aria-selected', 'true');
      } else {
        btn.classList.remove('active');
        btn.removeAttribute('aria-current');
        btn.setAttribute('aria-selected', 'false');
      }
    });
  }

  /**
   * Mettre à jour l'affichage selon le mode
   */
  function updateDisplay() {
    if (isDesktop) {
      // Desktop : afficher toutes les cartes
      cards.forEach(card => {
        card.classList.add('active');
        card.classList.remove('entering', 'loading');
      });
    } else {
      // Mobile : afficher seulement la carte active
      showCard(currentCard, false);
    }
  }

  /**
   * Annoncer le changement de carte pour l'accessibilité
   */
  function announceCardChange() {
    const currentCardElement = cards[currentCard];
    
    if (currentCardElement) {
      const tabBtn = tabButtons[currentCard];
      const tabText = tabBtn ? tabBtn.querySelector('.events-tab-text') : null;
      
      if (tabText) {
        const announcement = document.createElement('div');
        announcement.setAttribute('role', 'status');
        announcement.setAttribute('aria-live', 'polite');
        announcement.setAttribute('aria-atomic', 'true');
        announcement.className = 'sr-only';
        announcement.textContent = `Affichage de : ${tabText.textContent}`;
        
        document.body.appendChild(announcement);
        
        setTimeout(() => {
          document.body.removeChild(announcement);
        }, 1000);
      }
    }
  }

  /**
   * Afficher l'indice de swipe
   */
  function showSwipeHint() {
    const container = document.getElementById('eventsCardsContainer');
    if (!container) return;

    const hint = document.createElement('div');
    hint.className = 'events-swipe-hint show';
    hint.textContent = '← Balayez pour changer →';
    hint.setAttribute('aria-hidden', 'true');
    
    container.appendChild(hint);

    setTimeout(() => {
      hint.classList.remove('show');
      setTimeout(() => {
        if (hint.parentNode) {
          hint.parentNode.removeChild(hint);
        }
      }, 300);
    }, CONFIG.swipeHintDuration);
  }

  /**
   * Initialiser l'effet parallax (si disponible)
   */
  function initParallax() {
    const section = document.querySelector('.events-section');
    if (!section || !window.jarallax) return;

    try {
      jarallax(section, {
        speed: 0.45,
        imgPosition: '50% 40%'
      });
    } catch (e) {
      console.warn('Events Tabs: Parallax non disponible', e);
    }
  }

  /**
   * Démarrage
   */
  if (document.readyState === 'loading') {
    document.addEventListener('DOMContentLoaded', () => {
      init();
      // Initialiser le parallax après un court délai
      setTimeout(initParallax, 100);
    });
  } else {
    init();
    setTimeout(initParallax, 100);
  }

  // Export pour debug
  window.EventsTabs = {
    showCard,
    getCurrentCard: () => currentCard,
    getTotalCards: () => totalCards,
    isDesktop: () => isDesktop,
    nextCard: () => showCard(currentCard + 1, true),
    prevCard: () => showCard(currentCard - 1, true)
  };

})();
